# Jammal Perfume - AI Coding Guidelines

## Architecture Overview

**Jammal Perfume** is a luxury fragrance e-commerce platform built with **Next.js 16** + **TypeScript**, featuring a modern product catalog, shopping cart, checkout flow, and admin dashboard.

### Core Tech Stack
- **Frontend**: Next.js (App Router), React 19, TypeScript
- **Styling**: Tailwind CSS 4, Shadcn/ui components, Radix UI primitives
- **State Management**: Zustand (client-side cart persistence via localStorage)
- **Database**: SQLite + Prisma ORM
- **Authentication**: Clerk (OAuth + JWT-based user management)
- **Payment**: Razorpay integration
- **Forms**: React Hook Form + Zod validation
- **Images**: Next.js Image optimization with CDN support (Cloudinary, Supabase, Unsplash)

### Project Structure
```
app/                      # Next.js App Router pages
  api/                    # API routes (route.ts) for orders, products, search, payment
  admin/                  # Protected admin dashboard (auth via Clerk middleware)
  [slug]/                 # Dynamic collection & product pages
components/
  ui/                     # Shadcn/ui base components (buttons, forms, dialogs)
  layout/                 # Header, Footer (Header uses Zustand cart store)
  home/                   # Hero, CategoryGrid, ProductCarousel (uses Prisma data)
  product/                # ProductCard, ProductDetails, ProductFilters
store/                    # Zustand stores (cart-store.ts with persist middleware)
prisma/
  schema.prisma           # SQLite schema: User, Product, Category, Order, Review
  seed.ts                 # Seeding categories and sample products via upsert
```

## Key Patterns & Conventions

### Database & Data Access
- **SQLite limitations**: Uses String instead of native Postgres/MySQL enums; JSON stored as stringified JSON; comma-separated image strings
- **Prisma instantiation**: Each API route creates `new PrismaClient()` (development patternâ€”consider singleton in production)
- **Price handling**: Always `Float` type; cast to `Number(p.price)` when serializing to avoid type mismatches
- **Fetch pattern**: API routes use `Promise.all([query1, query2])` for parallel data fetching (see `app/api/orders/route.ts`)

### Component Patterns
- **"use client" directive**: Client components (Header, forms) explicitly marked; server components fetch Prisma data directly
- **Props structure**: Components receive plain objects (no Redux actions), styled with `cn()` utility from `@/lib/utils`
- **Shadcn Integration**: Import UI primitives from `@/components/ui/` (auto-generated by `shadcn-ui` CLI in `components.json`)

### State Management & Persistence
- **Zustand + persist**: Cart items persisted to localStorage via `persist()` middleware; always check `useCartStore((state) => state.items)`
- **Variant handling**: Cart items distinguish products by both `id` and optional `variant` field (e.g., size: 6ml vs 12ml from `seed.ts`)

### Authentication & Authorization
- **Clerk middleware**: Defined in `middleware.ts`; protects `/admin/*` routes via `createRouteMatcher`
- **User lookup**: API routes convert Clerk's `clerkId` to internal Prisma `User.id` (see `app/api/orders/route.ts`)
- **Clerk UI**: `<SignedIn>`, `<SignedOut>`, `<SignInButton>`, `<UserButton>` in Header

### Type Safety
- **tsconfig.json paths**: `@/*` aliases for imports (e.g., `@/components`, `@/lib/utils`, `@/store`)
- **Strict mode enabled**: TypeScript strict checking is on
- **Zod validation**: Forms use Zod schemas for runtime validation before submission

## Development Workflow

### Running the Project
```bash
npm run dev        # Start Next.js dev server (port 3000)
npm run build      # Production build
npm run start      # Run production build
npm run lint       # Run ESLint
npx prisma db seed # Seed database with categories/products
```

### Database Setup
- Default SQLite path: `prisma/dev.db`
- Seed adds 4 categories (Attar, Perfume Spray, Bakhoor, Gift Sets) + sample products
- Use `prisma db push` after schema changes (no migrations for SQLite dev workflow)

### Adding New Features
1. **New API endpoint**: Create `app/api/[feature]/route.ts`, handle auth with `auth()` from Clerk
2. **New model**: Update `prisma/schema.prisma`, run `npx prisma db push`, add seed data
3. **New component**: Import Shadcn primitives via `@/components/ui/`, use `cn()` for classNames
4. **Form validation**: Define Zod schema, pass to `useForm()` from React Hook Form

## Critical Knowledge for Agents

### Common Gotchas
- **Image fields**: Products store images as `String` (comma-separated or JSON stringified), not native arrays
- **Variants**: Stored as JSON string (`variants: String?`); parse/stringify when needed
- **Pagination**: API routes expect `page` and `limit` search params; calculate skip as `(page - 1) * limit`
- **Cart merging**: `addItem()` merges quantities if product + variant already exists

### External Integrations
- **Razorpay**: Configured in API routes for payment verification (`app/api/verify-payment/route.ts`)
- **Image CDNs**: Whitelist domains in `next.config.ts` (Cloudinary, Supabase, Unsplash, AWS S3)
- **Clerk**: Requires `.env.local` with `NEXT_PUBLIC_CLERK_PUBLISHABLE_KEY` and `CLERK_SECRET_KEY`

### Testing & Debugging Tips
- Use `npm run dev` + VS Code debugger for Next.js (set breakpoints in API routes)
- Check browser console for Zustand store state: `window.__ZUSTAND__` (if persist logging enabled)
- Verify Clerk auth: Check network tab for `/api/auth/callback/clerk` responses
- Test Prisma queries: Run `npx prisma studio` to browse SQLite schema interactively
